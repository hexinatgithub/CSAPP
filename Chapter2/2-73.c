#include <stdio.h>

//原答案在 http://www.programmershare.com/1587484/

int saturating_add(int x, int y){
	/*
	这道题想了很久，参考网上的答案，想同了，看到网上的答案有的很复杂，看不太懂，找到了一个非常好的答案，简单明了
	*/
	int sum = x + y;
	int nbit = sizeof(x) << 3;
	//因为overflow的话x,y,sum的符号位只有两种情况:
	//第一种:110
	//第二种:001
	//这两种情况都要是sum的符号位和x,y的符号位都不同，既x,y的符号位要相同，而x,y和sum的符号位不同
	//则使用((x ^ sum) & (y ^ sum))来判断这种情况，只有当x,y的符号位相同的时候，和sum的符号位不同的时候，为1

	//如果溢出则产生w-bit全为1的数，否则为0
	int of = ((x ^ sum) & (y ^ sum)) >> (nbit - 1);
	//接下来要思考的是，当我们得到of为w-bit个1的数的时候，该如何判断返回值是01...1还是10...0呢？
	//这下使用到了x的符号位,当x为正数的时候，全为0，否则全为1
	//这里要注意的是当右移的时候移动位数大于或者等于w的时候，c语言标准是没有定义后果的，所以为了安全还是右移nbit - 1
	int sign = x >> nbit - 1;
	//下面还是两种情况
	//当x为正数的时候，sign=[0...0],这个时候溢出的话则要返回[01...1]
	//而当x为负数的时候，sign=[1...1],这个时候溢出的话则要返回[10...0]
	//这个时候将of作为判断是否要进行saturate，则使用(sum | of),溢出则变为[1...1]
	//如果溢出的话，则x为正数的，则由of - [10...0] = [01...1]，也就是说sign为[0...0]的时候，减去[10...0]
	//如果x为负数，则of - [01...1] = [10...0],sign为[1...1]的时候，减去[01...1]
	//则使用(1 << nbit - 1) ^ sign用来产生减去的数，然后和of与来判断是否要进行减法,则如下:
	return (sum | of) - ((1 << nbit -1) ^ sign) & of;
}